
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

struct RNCNaverMapArrowheadPathCoordsStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapArrowheadPathCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapArrowheadPathCoordsStruct &value) {
  return "[Object RNCNaverMapArrowheadPathCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapArrowheadPathCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapArrowheadPathCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}

class RNCNaverMapArrowheadPathProps final : public ViewProps {
 public:
  RNCNaverMapArrowheadPathProps() = default;
  RNCNaverMapArrowheadPathProps(const PropsParserContext& context, const RNCNaverMapArrowheadPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  std::vector<RNCNaverMapArrowheadPathCoordsStruct> coords{};
  double width{0.0};
  double outlineWidth{0.0};
  int color{0};
  int outlineColor{0};
  double headSizeRatio{0.0};
};

struct RNCNaverMapCircleCoordStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapCircleCoordStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapCircleCoordStruct &value) {
  return "[Object RNCNaverMapCircleCoordStruct]";
}
class RNCNaverMapCircleProps final : public ViewProps {
 public:
  RNCNaverMapCircleProps() = default;
  RNCNaverMapCircleProps(const PropsParserContext& context, const RNCNaverMapCircleProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapCircleCoordStruct coord{};
  double radius{0.0};
  int color{0};
  int outlineColor{0};
  double outlineWidth{0.0};
};

struct RNCNaverMapGroundImageStruct {
  std::string symbol{};
  std::string rnAssetUri{};
  std::string httpUri{};
  std::string assetName{};
  std::string reuseIdentifier{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapGroundImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapGroundImageStruct &value) {
  return "[Object RNCNaverMapGroundImageStruct]";
}

struct RNCNaverMapGroundRegionStruct {
  double latitude{0.0};
  double longitude{0.0};
  double latitudeDelta{0.0};
  double longitudeDelta{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapGroundRegionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapGroundRegionStruct &value) {
  return "[Object RNCNaverMapGroundRegionStruct]";
}
class RNCNaverMapGroundProps final : public ViewProps {
 public:
  RNCNaverMapGroundProps() = default;
  RNCNaverMapGroundProps(const PropsParserContext& context, const RNCNaverMapGroundProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapGroundImageStruct image{};
  RNCNaverMapGroundRegionStruct region{};
};

struct RNCNaverMapMarkerCoordStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerCoordStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapMarkerCoordStruct &value) {
  return "[Object RNCNaverMapMarkerCoordStruct]";
}

struct RNCNaverMapMarkerAnchorStruct {
  double x{0.0};
  double y{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerAnchorStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_x = map.find("x");
  if (tmp_x != map.end()) {
    fromRawValue(context, tmp_x->second, result.x);
  }
  auto tmp_y = map.find("y");
  if (tmp_y != map.end()) {
    fromRawValue(context, tmp_y->second, result.y);
  }
}

static inline std::string toString(const RNCNaverMapMarkerAnchorStruct &value) {
  return "[Object RNCNaverMapMarkerAnchorStruct]";
}

struct RNCNaverMapMarkerImageStruct {
  std::string symbol{};
  std::string rnAssetUri{};
  std::string httpUri{};
  std::string assetName{};
  std::string reuseIdentifier{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapMarkerImageStruct &value) {
  return "[Object RNCNaverMapMarkerImageStruct]";
}

struct RNCNaverMapMarkerCaptionStruct {
  std::string key{};
  std::string text{};
  double requestedWidth{0.0};
  int align{0};
  double offset{0.0};
  int color{0};
  int haloColor{0};
  double textSize{0.0};
  double minZoom{0.0};
  double maxZoom{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerCaptionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_text = map.find("text");
  if (tmp_text != map.end()) {
    fromRawValue(context, tmp_text->second, result.text);
  }
  auto tmp_requestedWidth = map.find("requestedWidth");
  if (tmp_requestedWidth != map.end()) {
    fromRawValue(context, tmp_requestedWidth->second, result.requestedWidth);
  }
  auto tmp_align = map.find("align");
  if (tmp_align != map.end()) {
    fromRawValue(context, tmp_align->second, result.align);
  }
  auto tmp_offset = map.find("offset");
  if (tmp_offset != map.end()) {
    fromRawValue(context, tmp_offset->second, result.offset);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_haloColor = map.find("haloColor");
  if (tmp_haloColor != map.end()) {
    fromRawValue(context, tmp_haloColor->second, result.haloColor);
  }
  auto tmp_textSize = map.find("textSize");
  if (tmp_textSize != map.end()) {
    fromRawValue(context, tmp_textSize->second, result.textSize);
  }
  auto tmp_minZoom = map.find("minZoom");
  if (tmp_minZoom != map.end()) {
    fromRawValue(context, tmp_minZoom->second, result.minZoom);
  }
  auto tmp_maxZoom = map.find("maxZoom");
  if (tmp_maxZoom != map.end()) {
    fromRawValue(context, tmp_maxZoom->second, result.maxZoom);
  }
}

static inline std::string toString(const RNCNaverMapMarkerCaptionStruct &value) {
  return "[Object RNCNaverMapMarkerCaptionStruct]";
}

struct RNCNaverMapMarkerSubCaptionStruct {
  std::string key{};
  std::string text{};
  int color{0};
  int haloColor{0};
  double textSize{0.0};
  double requestedWidth{0.0};
  double minZoom{0.0};
  double maxZoom{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerSubCaptionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_text = map.find("text");
  if (tmp_text != map.end()) {
    fromRawValue(context, tmp_text->second, result.text);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_haloColor = map.find("haloColor");
  if (tmp_haloColor != map.end()) {
    fromRawValue(context, tmp_haloColor->second, result.haloColor);
  }
  auto tmp_textSize = map.find("textSize");
  if (tmp_textSize != map.end()) {
    fromRawValue(context, tmp_textSize->second, result.textSize);
  }
  auto tmp_requestedWidth = map.find("requestedWidth");
  if (tmp_requestedWidth != map.end()) {
    fromRawValue(context, tmp_requestedWidth->second, result.requestedWidth);
  }
  auto tmp_minZoom = map.find("minZoom");
  if (tmp_minZoom != map.end()) {
    fromRawValue(context, tmp_minZoom->second, result.minZoom);
  }
  auto tmp_maxZoom = map.find("maxZoom");
  if (tmp_maxZoom != map.end()) {
    fromRawValue(context, tmp_maxZoom->second, result.maxZoom);
  }
}

static inline std::string toString(const RNCNaverMapMarkerSubCaptionStruct &value) {
  return "[Object RNCNaverMapMarkerSubCaptionStruct]";
}
class RNCNaverMapMarkerProps final : public ViewProps {
 public:
  RNCNaverMapMarkerProps() = default;
  RNCNaverMapMarkerProps(const PropsParserContext& context, const RNCNaverMapMarkerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapMarkerCoordStruct coord{};
  double width{0.0};
  double height{0.0};
  RNCNaverMapMarkerAnchorStruct anchor{};
  double angle{0.0};
  bool isFlatEnabled{false};
  bool isIconPerspectiveEnabled{false};
  double alpha{0.0};
  bool isHideCollidedSymbols{false};
  bool isHideCollidedMarkers{false};
  bool isHideCollidedCaptions{false};
  bool isForceShowIcon{false};
  int tintColor{0};
  RNCNaverMapMarkerImageStruct image{};
  RNCNaverMapMarkerCaptionStruct caption{};
  RNCNaverMapMarkerSubCaptionStruct subCaption{};
};

struct RNCNaverMapPathCoordsStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPathCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPathCoordsStruct &value) {
  return "[Object RNCNaverMapPathCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapPathCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapPathCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapPathPatternImageStruct {
  std::string symbol{};
  std::string rnAssetUri{};
  std::string httpUri{};
  std::string assetName{};
  std::string reuseIdentifier{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPathPatternImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapPathPatternImageStruct &value) {
  return "[Object RNCNaverMapPathPatternImageStruct]";
}
class RNCNaverMapPathProps final : public ViewProps {
 public:
  RNCNaverMapPathProps() = default;
  RNCNaverMapPathProps(const PropsParserContext& context, const RNCNaverMapPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  std::vector<RNCNaverMapPathCoordsStruct> coords{};
  double width{0.0};
  double outlineWidth{0.0};
  int patternInterval{0};
  RNCNaverMapPathPatternImageStruct patternImage{};
  double progress{0.0};
  int color{0};
  int passedColor{0};
  int outlineColor{0};
  int passedOutlineColor{0};
  bool isHideCollidedSymbols{false};
  bool isHideCollidedMarkers{false};
  bool isHideCollidedCaptions{false};
};

struct RNCNaverMapPolygonGeometriesCoordsStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolygonGeometriesCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPolygonGeometriesCoordsStruct &value) {
  return "[Object RNCNaverMapPolygonGeometriesCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapPolygonGeometriesCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapPolygonGeometriesCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapPolygonGeometriesHolesStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolygonGeometriesHolesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPolygonGeometriesHolesStruct &value) {
  return "[Object RNCNaverMapPolygonGeometriesHolesStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<std::vector<RNCNaverMapPolygonGeometriesHolesStruct>> &result) {
  auto items = (std::vector<std::vector<RawValue>>)value;
  for (const std::vector<RawValue> &item : items) {
    auto nestedArray = std::vector<RNCNaverMapPolygonGeometriesHolesStruct>{};
    for (const RawValue &nestedItem : item) {
      RNCNaverMapPolygonGeometriesHolesStruct newItem;
      fromRawValue(context, nestedItem, newItem);
      nestedArray.emplace_back(newItem);
    }
    result.emplace_back(nestedArray);
  }
}


struct RNCNaverMapPolygonGeometriesStruct {
  std::vector<RNCNaverMapPolygonGeometriesCoordsStruct> coords{};
  std::vector<std::vector<RNCNaverMapPolygonGeometriesHolesStruct>> holes{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolygonGeometriesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_coords = map.find("coords");
  if (tmp_coords != map.end()) {
    fromRawValue(context, tmp_coords->second, result.coords);
  }
  auto tmp_holes = map.find("holes");
  if (tmp_holes != map.end()) {
    fromRawValue(context, tmp_holes->second, result.holes);
  }
}

static inline std::string toString(const RNCNaverMapPolygonGeometriesStruct &value) {
  return "[Object RNCNaverMapPolygonGeometriesStruct]";
}
class RNCNaverMapPolygonProps final : public ViewProps {
 public:
  RNCNaverMapPolygonProps() = default;
  RNCNaverMapPolygonProps(const PropsParserContext& context, const RNCNaverMapPolygonProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapPolygonGeometriesStruct geometries{};
  int color{0};
  int outlineColor{0};
  double outlineWidth{0.0};
};

enum class RNCNaverMapPolylineCapType { Round, Butt, Square };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolylineCapType &result) {
  auto string = (std::string)value;
  if (string == "Round") { result = RNCNaverMapPolylineCapType::Round; return; }
  if (string == "Butt") { result = RNCNaverMapPolylineCapType::Butt; return; }
  if (string == "Square") { result = RNCNaverMapPolylineCapType::Square; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapPolylineCapType &value) {
  switch (value) {
    case RNCNaverMapPolylineCapType::Round: return "Round";
    case RNCNaverMapPolylineCapType::Butt: return "Butt";
    case RNCNaverMapPolylineCapType::Square: return "Square";
  }
}
enum class RNCNaverMapPolylineJoinType { Bevel, Miter, Round };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolylineJoinType &result) {
  auto string = (std::string)value;
  if (string == "Bevel") { result = RNCNaverMapPolylineJoinType::Bevel; return; }
  if (string == "Miter") { result = RNCNaverMapPolylineJoinType::Miter; return; }
  if (string == "Round") { result = RNCNaverMapPolylineJoinType::Round; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapPolylineJoinType &value) {
  switch (value) {
    case RNCNaverMapPolylineJoinType::Bevel: return "Bevel";
    case RNCNaverMapPolylineJoinType::Miter: return "Miter";
    case RNCNaverMapPolylineJoinType::Round: return "Round";
  }
}
struct RNCNaverMapPolylineCoordsStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolylineCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPolylineCoordsStruct &value) {
  return "[Object RNCNaverMapPolylineCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapPolylineCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapPolylineCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}

class RNCNaverMapPolylineProps final : public ViewProps {
 public:
  RNCNaverMapPolylineProps() = default;
  RNCNaverMapPolylineProps(const PropsParserContext& context, const RNCNaverMapPolylineProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  int globalZIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  std::vector<RNCNaverMapPolylineCoordsStruct> coords{};
  double width{0.0};
  int color{0};
  std::vector<int> pattern{};
  RNCNaverMapPolylineCapType capType{RNCNaverMapPolylineCapType::Round};
  RNCNaverMapPolylineJoinType joinType{RNCNaverMapPolylineJoinType::Round};
};

enum class RNCNaverMapViewMapType { Basic, Navi, Satellite, Hybrid, Terrain, NaviHybrid, None };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewMapType &result) {
  auto string = (std::string)value;
  if (string == "Basic") { result = RNCNaverMapViewMapType::Basic; return; }
  if (string == "Navi") { result = RNCNaverMapViewMapType::Navi; return; }
  if (string == "Satellite") { result = RNCNaverMapViewMapType::Satellite; return; }
  if (string == "Hybrid") { result = RNCNaverMapViewMapType::Hybrid; return; }
  if (string == "Terrain") { result = RNCNaverMapViewMapType::Terrain; return; }
  if (string == "NaviHybrid") { result = RNCNaverMapViewMapType::NaviHybrid; return; }
  if (string == "None") { result = RNCNaverMapViewMapType::None; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapViewMapType &value) {
  switch (value) {
    case RNCNaverMapViewMapType::Basic: return "Basic";
    case RNCNaverMapViewMapType::Navi: return "Navi";
    case RNCNaverMapViewMapType::Satellite: return "Satellite";
    case RNCNaverMapViewMapType::Hybrid: return "Hybrid";
    case RNCNaverMapViewMapType::Terrain: return "Terrain";
    case RNCNaverMapViewMapType::NaviHybrid: return "NaviHybrid";
    case RNCNaverMapViewMapType::None: return "None";
  }
}
enum class RNCNaverMapViewLogoAlign { TopLeft, TopRight, BottomLeft, BottomRight };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLogoAlign &result) {
  auto string = (std::string)value;
  if (string == "TopLeft") { result = RNCNaverMapViewLogoAlign::TopLeft; return; }
  if (string == "TopRight") { result = RNCNaverMapViewLogoAlign::TopRight; return; }
  if (string == "BottomLeft") { result = RNCNaverMapViewLogoAlign::BottomLeft; return; }
  if (string == "BottomRight") { result = RNCNaverMapViewLogoAlign::BottomRight; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapViewLogoAlign &value) {
  switch (value) {
    case RNCNaverMapViewLogoAlign::TopLeft: return "TopLeft";
    case RNCNaverMapViewLogoAlign::TopRight: return "TopRight";
    case RNCNaverMapViewLogoAlign::BottomLeft: return "BottomLeft";
    case RNCNaverMapViewLogoAlign::BottomRight: return "BottomRight";
  }
}
struct RNCNaverMapViewInitialCameraStruct {
  double latitude{0.0};
  double longitude{0.0};
  double zoom{0.0};
  double tilt{0.0};
  double bearing{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewInitialCameraStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_zoom = map.find("zoom");
  if (tmp_zoom != map.end()) {
    fromRawValue(context, tmp_zoom->second, result.zoom);
  }
  auto tmp_tilt = map.find("tilt");
  if (tmp_tilt != map.end()) {
    fromRawValue(context, tmp_tilt->second, result.tilt);
  }
  auto tmp_bearing = map.find("bearing");
  if (tmp_bearing != map.end()) {
    fromRawValue(context, tmp_bearing->second, result.bearing);
  }
}

static inline std::string toString(const RNCNaverMapViewInitialCameraStruct &value) {
  return "[Object RNCNaverMapViewInitialCameraStruct]";
}

struct RNCNaverMapViewCameraStruct {
  double latitude{0.0};
  double longitude{0.0};
  double zoom{0.0};
  double tilt{0.0};
  double bearing{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewCameraStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_zoom = map.find("zoom");
  if (tmp_zoom != map.end()) {
    fromRawValue(context, tmp_zoom->second, result.zoom);
  }
  auto tmp_tilt = map.find("tilt");
  if (tmp_tilt != map.end()) {
    fromRawValue(context, tmp_tilt->second, result.tilt);
  }
  auto tmp_bearing = map.find("bearing");
  if (tmp_bearing != map.end()) {
    fromRawValue(context, tmp_bearing->second, result.bearing);
  }
}

static inline std::string toString(const RNCNaverMapViewCameraStruct &value) {
  return "[Object RNCNaverMapViewCameraStruct]";
}

struct RNCNaverMapViewInitialRegionStruct {
  double latitude{0.0};
  double longitude{0.0};
  double latitudeDelta{0.0};
  double longitudeDelta{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewInitialRegionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapViewInitialRegionStruct &value) {
  return "[Object RNCNaverMapViewInitialRegionStruct]";
}

struct RNCNaverMapViewRegionStruct {
  double latitude{0.0};
  double longitude{0.0};
  double latitudeDelta{0.0};
  double longitudeDelta{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewRegionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapViewRegionStruct &value) {
  return "[Object RNCNaverMapViewRegionStruct]";
}

struct RNCNaverMapViewMapPaddingStruct {
  double top{0.0};
  double right{0.0};
  double bottom{0.0};
  double left{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewMapPaddingStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
}

static inline std::string toString(const RNCNaverMapViewMapPaddingStruct &value) {
  return "[Object RNCNaverMapViewMapPaddingStruct]";
}

struct RNCNaverMapViewLogoMarginStruct {
  double top{0.0};
  double right{0.0};
  double bottom{0.0};
  double left{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLogoMarginStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
}

static inline std::string toString(const RNCNaverMapViewLogoMarginStruct &value) {
  return "[Object RNCNaverMapViewLogoMarginStruct]";
}

struct RNCNaverMapViewExtentStruct {
  double latitude{0.0};
  double longitude{0.0};
  double latitudeDelta{0.0};
  double longitudeDelta{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewExtentStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapViewExtentStruct &value) {
  return "[Object RNCNaverMapViewExtentStruct]";
}

struct RNCNaverMapViewClustersClustersMarkersImageStruct {
  std::string symbol{};
  std::string rnAssetUri{};
  std::string httpUri{};
  std::string assetName{};
  std::string reuseIdentifier{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersClustersMarkersImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersClustersMarkersImageStruct &value) {
  return "[Object RNCNaverMapViewClustersClustersMarkersImageStruct]";
}

struct RNCNaverMapViewClustersClustersMarkersStruct {
  double latitude{0.0};
  double longitude{0.0};
  std::string identifier{};
  RNCNaverMapViewClustersClustersMarkersImageStruct image{};
  double width{0.0};
  double height{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersClustersMarkersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_identifier = map.find("identifier");
  if (tmp_identifier != map.end()) {
    fromRawValue(context, tmp_identifier->second, result.identifier);
  }
  auto tmp_image = map.find("image");
  if (tmp_image != map.end()) {
    fromRawValue(context, tmp_image->second, result.image);
  }
  auto tmp_width = map.find("width");
  if (tmp_width != map.end()) {
    fromRawValue(context, tmp_width->second, result.width);
  }
  auto tmp_height = map.find("height");
  if (tmp_height != map.end()) {
    fromRawValue(context, tmp_height->second, result.height);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersClustersMarkersStruct &value) {
  return "[Object RNCNaverMapViewClustersClustersMarkersStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapViewClustersClustersMarkersStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapViewClustersClustersMarkersStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapViewClustersClustersStruct {
  std::string key{};
  double width{0.0};
  double height{0.0};
  std::vector<RNCNaverMapViewClustersClustersMarkersStruct> markers{};
  double screenDistance{0.0};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool animate{false};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersClustersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_width = map.find("width");
  if (tmp_width != map.end()) {
    fromRawValue(context, tmp_width->second, result.width);
  }
  auto tmp_height = map.find("height");
  if (tmp_height != map.end()) {
    fromRawValue(context, tmp_height->second, result.height);
  }
  auto tmp_markers = map.find("markers");
  if (tmp_markers != map.end()) {
    fromRawValue(context, tmp_markers->second, result.markers);
  }
  auto tmp_screenDistance = map.find("screenDistance");
  if (tmp_screenDistance != map.end()) {
    fromRawValue(context, tmp_screenDistance->second, result.screenDistance);
  }
  auto tmp_minZoom = map.find("minZoom");
  if (tmp_minZoom != map.end()) {
    fromRawValue(context, tmp_minZoom->second, result.minZoom);
  }
  auto tmp_maxZoom = map.find("maxZoom");
  if (tmp_maxZoom != map.end()) {
    fromRawValue(context, tmp_maxZoom->second, result.maxZoom);
  }
  auto tmp_animate = map.find("animate");
  if (tmp_animate != map.end()) {
    fromRawValue(context, tmp_animate->second, result.animate);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersClustersStruct &value) {
  return "[Object RNCNaverMapViewClustersClustersStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapViewClustersClustersStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapViewClustersClustersStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapViewClustersStruct {
  std::string key{};
  std::vector<RNCNaverMapViewClustersClustersStruct> clusters{};
  bool isLeafTapCallbackExist{false};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_clusters = map.find("clusters");
  if (tmp_clusters != map.end()) {
    fromRawValue(context, tmp_clusters->second, result.clusters);
  }
  auto tmp_isLeafTapCallbackExist = map.find("isLeafTapCallbackExist");
  if (tmp_isLeafTapCallbackExist != map.end()) {
    fromRawValue(context, tmp_isLeafTapCallbackExist->second, result.isLeafTapCallbackExist);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersStruct &value) {
  return "[Object RNCNaverMapViewClustersStruct]";
}

struct RNCNaverMapViewLocationOverlayPositionStruct {
  double latitude{0.0};
  double longitude{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLocationOverlayPositionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapViewLocationOverlayPositionStruct &value) {
  return "[Object RNCNaverMapViewLocationOverlayPositionStruct]";
}

struct RNCNaverMapViewLocationOverlayImageStruct {
  std::string symbol{};
  std::string rnAssetUri{};
  std::string httpUri{};
  std::string assetName{};
  std::string reuseIdentifier{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLocationOverlayImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapViewLocationOverlayImageStruct &value) {
  return "[Object RNCNaverMapViewLocationOverlayImageStruct]";
}

struct RNCNaverMapViewLocationOverlayAnchorStruct {
  double x{0.0};
  double y{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLocationOverlayAnchorStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_x = map.find("x");
  if (tmp_x != map.end()) {
    fromRawValue(context, tmp_x->second, result.x);
  }
  auto tmp_y = map.find("y");
  if (tmp_y != map.end()) {
    fromRawValue(context, tmp_y->second, result.y);
  }
}

static inline std::string toString(const RNCNaverMapViewLocationOverlayAnchorStruct &value) {
  return "[Object RNCNaverMapViewLocationOverlayAnchorStruct]";
}

struct RNCNaverMapViewLocationOverlaySubImageStruct {
  std::string symbol{};
  std::string rnAssetUri{};
  std::string httpUri{};
  std::string assetName{};
  std::string reuseIdentifier{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLocationOverlaySubImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapViewLocationOverlaySubImageStruct &value) {
  return "[Object RNCNaverMapViewLocationOverlaySubImageStruct]";
}

struct RNCNaverMapViewLocationOverlaySubAnchorStruct {
  double x{0.0};
  double y{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLocationOverlaySubAnchorStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_x = map.find("x");
  if (tmp_x != map.end()) {
    fromRawValue(context, tmp_x->second, result.x);
  }
  auto tmp_y = map.find("y");
  if (tmp_y != map.end()) {
    fromRawValue(context, tmp_y->second, result.y);
  }
}

static inline std::string toString(const RNCNaverMapViewLocationOverlaySubAnchorStruct &value) {
  return "[Object RNCNaverMapViewLocationOverlaySubAnchorStruct]";
}

struct RNCNaverMapViewLocationOverlayStruct {
  bool isVisible{false};
  RNCNaverMapViewLocationOverlayPositionStruct position{};
  double bearing{0.0};
  RNCNaverMapViewLocationOverlayImageStruct image{};
  double imageWidth{0.0};
  double imageHeight{0.0};
  RNCNaverMapViewLocationOverlayAnchorStruct anchor{};
  RNCNaverMapViewLocationOverlaySubImageStruct subImage{};
  double subImageWidth{0.0};
  double subImageHeight{0.0};
  RNCNaverMapViewLocationOverlaySubAnchorStruct subAnchor{};
  double circleRadius{0.0};
  int circleColor{0};
  double circleOutlineWidth{0.0};
  int circleOutlineColor{0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLocationOverlayStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_isVisible = map.find("isVisible");
  if (tmp_isVisible != map.end()) {
    fromRawValue(context, tmp_isVisible->second, result.isVisible);
  }
  auto tmp_position = map.find("position");
  if (tmp_position != map.end()) {
    fromRawValue(context, tmp_position->second, result.position);
  }
  auto tmp_bearing = map.find("bearing");
  if (tmp_bearing != map.end()) {
    fromRawValue(context, tmp_bearing->second, result.bearing);
  }
  auto tmp_image = map.find("image");
  if (tmp_image != map.end()) {
    fromRawValue(context, tmp_image->second, result.image);
  }
  auto tmp_imageWidth = map.find("imageWidth");
  if (tmp_imageWidth != map.end()) {
    fromRawValue(context, tmp_imageWidth->second, result.imageWidth);
  }
  auto tmp_imageHeight = map.find("imageHeight");
  if (tmp_imageHeight != map.end()) {
    fromRawValue(context, tmp_imageHeight->second, result.imageHeight);
  }
  auto tmp_anchor = map.find("anchor");
  if (tmp_anchor != map.end()) {
    fromRawValue(context, tmp_anchor->second, result.anchor);
  }
  auto tmp_subImage = map.find("subImage");
  if (tmp_subImage != map.end()) {
    fromRawValue(context, tmp_subImage->second, result.subImage);
  }
  auto tmp_subImageWidth = map.find("subImageWidth");
  if (tmp_subImageWidth != map.end()) {
    fromRawValue(context, tmp_subImageWidth->second, result.subImageWidth);
  }
  auto tmp_subImageHeight = map.find("subImageHeight");
  if (tmp_subImageHeight != map.end()) {
    fromRawValue(context, tmp_subImageHeight->second, result.subImageHeight);
  }
  auto tmp_subAnchor = map.find("subAnchor");
  if (tmp_subAnchor != map.end()) {
    fromRawValue(context, tmp_subAnchor->second, result.subAnchor);
  }
  auto tmp_circleRadius = map.find("circleRadius");
  if (tmp_circleRadius != map.end()) {
    fromRawValue(context, tmp_circleRadius->second, result.circleRadius);
  }
  auto tmp_circleColor = map.find("circleColor");
  if (tmp_circleColor != map.end()) {
    fromRawValue(context, tmp_circleColor->second, result.circleColor);
  }
  auto tmp_circleOutlineWidth = map.find("circleOutlineWidth");
  if (tmp_circleOutlineWidth != map.end()) {
    fromRawValue(context, tmp_circleOutlineWidth->second, result.circleOutlineWidth);
  }
  auto tmp_circleOutlineColor = map.find("circleOutlineColor");
  if (tmp_circleOutlineColor != map.end()) {
    fromRawValue(context, tmp_circleOutlineColor->second, result.circleOutlineColor);
  }
}

static inline std::string toString(const RNCNaverMapViewLocationOverlayStruct &value) {
  return "[Object RNCNaverMapViewLocationOverlayStruct]";
}
class RNCNaverMapViewProps final : public ViewProps {
 public:
  RNCNaverMapViewProps() = default;
  RNCNaverMapViewProps(const PropsParserContext& context, const RNCNaverMapViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNCNaverMapViewMapType mapType{RNCNaverMapViewMapType::Basic};
  int layerGroups{0};
  RNCNaverMapViewInitialCameraStruct initialCamera{};
  RNCNaverMapViewCameraStruct camera{};
  RNCNaverMapViewInitialRegionStruct initialRegion{};
  RNCNaverMapViewRegionStruct region{};
  int animationDuration{0};
  int animationEasing{0};
  bool isIndoorEnabled{false};
  bool isNightModeEnabled{false};
  bool isLiteModeEnabled{false};
  double lightness{0.0};
  double buildingHeight{0.0};
  double symbolScale{0.0};
  double symbolPerspectiveRatio{0.0};
  RNCNaverMapViewMapPaddingStruct mapPadding{};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isShowCompass{false};
  bool isShowScaleBar{false};
  bool isShowZoomControls{false};
  bool isShowIndoorLevelPicker{false};
  bool isShowLocationButton{false};
  RNCNaverMapViewLogoAlign logoAlign{RNCNaverMapViewLogoAlign::BottomLeft};
  RNCNaverMapViewLogoMarginStruct logoMargin{};
  RNCNaverMapViewExtentStruct extent{};
  bool isScrollGesturesEnabled{false};
  bool isZoomGesturesEnabled{false};
  bool isTiltGesturesEnabled{false};
  bool isRotateGesturesEnabled{false};
  bool isUseTextureViewAndroid{false};
  bool isStopGesturesEnabled{false};
  std::string locale{};
  RNCNaverMapViewClustersStruct clusters{};
  int fpsLimit{0};
  RNCNaverMapViewLocationOverlayStruct locationOverlay{};
};

} // namespace facebook::react
